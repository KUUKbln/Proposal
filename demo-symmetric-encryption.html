<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Demo: Symmetrische Verschl√ºsselung</title>
  <link rel="stylesheet" href="style.css" />
  <style>
    .controls {
      display: flex;
      gap: 0.5em;
      margin-top: 0.3em;
    }

    .output.stale {
      background-color: #fff6e0;
      border-color: #d99;
    }

    button.copy {
      font-size: 0.8em;
      padding: 0.3em 0.5em;
      margin-left: 0.5em;
      cursor: pointer;
    }

    .output-box {
      display: flex;
      align-items: center;
      gap: 0.5em;
    }

    .output-box .output {
      flex: 1;
    }
  </style>

  <!--
    Generiert von ChatGPT (GPT-4o) ‚Äì 2025-09-22 ‚Äì Version 1.0

    Anweisung / Prompt:
    Titel: "Demo: Symmetrische Verschl√ºsselung"
    Erstelle ein interaktives Web-Tool zur Demonstration symmetrischer Kryptografie
    mit WebCrypto API, das folgende Funktionen bietet:

    1. Ein Textfeld f√ºr die Eingabe einer Nachricht (Klartext oder Ciphertext).
    2. Eine immer sichtbare Ausgabefl√§che f√ºr den SHA-256-Hash der Nachricht (Hex).
    3. Ein Auswahlfeld (Select), um zwischen "Verschl√ºsseln" und "Entschl√ºsseln" zu w√§hlen.
    4. Ein Eingabefeld f√ºr den symmetrischen Schl√ºssel (Base64).
    5. Eine dynamische Ausgabefl√§che (verschl√ºsselte oder entschl√ºsselte Nachricht).
    6. Alle Ausgaben sollen automatisch bei √Ñnderungen neu berechnet werden.
    7. Ausgabe-Felder werden farblich hervorgehoben, wenn sie nicht aktuell sind.
    8. Kopier-Buttons f√ºr Hash, Schl√ºssel und Ergebnis.
    9. Warnhinweis: nicht f√ºr sicherheitsrelevante Anwendungen geeignet.
    10. Ziel: Lernhilfe f√ºr Entwickler:innen.
  -->
</head>
<body>
  <header>
    <h1>üîê Demo: Symmetrische Verschl√ºsselung</h1>
    <p class="meta">Generiert von GPT-4o ‚Äì 2025-09-22</p>
  </header>

  <main>
    <section class="warning">
      ‚ö†Ô∏è <strong>Sicherheitswarnung:</strong>
      Dieser Code wurde automatisch generiert und ist ungetestet.
      Nicht in produktiven oder sicherheitsrelevanten Systemen verwenden.
    </section>

    <label for="message">Nachricht (Klartext oder verschl√ºsselt):</label>
    <textarea id="message" rows="4" placeholder="Gib hier die Nachricht ein..."></textarea>

    <label for="hashOutput">SHA-256 Hash (Hex):</label>
    <div class="output-box">
      <div class="output" id="hashOutput"></div>
      <button class="copy" id="copyHash">Kopieren</button>
    </div>

    <label for="functionSelect">Funktion:</label>
    <select id="functionSelect">
      <option value="encrypt">Nachricht verschl√ºsseln (AES-GCM)</option>
      <option value="decrypt">Nachricht entschl√ºsseln (AES-GCM)</option>
    </select>

    <label for="keyInput">Schl√ºssel (Base64-kodiert):</label>
    <div class="output-box">
      <input type="text" id="keyInput" placeholder="Base64-Schl√ºssel eingeben oder erzeugen" />
      <button class="copy" id="copyKey">Kopieren</button>
    </div>

    <label for="resultOutput">Ergebnis:</label>
    <div class="output-box">
      <div class="output stale" id="resultOutput"></div>
      <button class="copy" id="copyResult">Kopieren</button>
    </div>

    <details style="margin-top: 2em;">
      <summary>‚ÑπÔ∏è Erkl√§rung: Verwendete WebCrypto-API</summary>
      <ul>
        <li><code>crypto.subtle.digest('SHA-256')</code>: Berechnet einen Hash √ºber die Nachricht.</li>
        <li><code>crypto.subtle.encrypt/decrypt</code>: Verschl√ºsselt oder entschl√ºsselt mit AES-GCM.</li>
        <li><code>importKey()</code>: Wandelt einen Base64-String in einen CryptoKey.</li>
        <li>IV (Initialisierungsvektor) wird automatisch erzeugt und dem Ciphertext vorangestellt.</li>
      </ul>
    </details>
  </main>

  <footer>
    <p>Generated by GPT-4o ‚Äì 2025 ‚Äì Demo-Version</p>
  </footer>

  <script>
    const messageInput = document.getElementById("message");
    const functionSelect = document.getElementById("functionSelect");
    const keyInput = document.getElementById("keyInput");
    const resultOutput = document.getElementById("resultOutput");
    const hashOutput = document.getElementById("hashOutput");

    const copyHashBtn = document.getElementById("copyHash");
    const copyKeyBtn = document.getElementById("copyKey");
    const copyResultBtn = document.getElementById("copyResult");

    function arrayBufferToHex(buffer) {
      return [...new Uint8Array(buffer)]
        .map(b => b.toString(16).padStart(2, "0"))
        .join("");
    }

    function base64ToArrayBuffer(base64) {
      try {
        const binary = atob(base64);
        const bytes = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) {
          bytes[i] = binary.charCodeAt(i);
        }
        return bytes.buffer;
      } catch {
        return null;
      }
    }

    function arrayBufferToBase64(buffer) {
      const bytes = new Uint8Array(buffer);
      let binary = "";
      for (let b of bytes) {
        binary += String.fromCharCode(b);
      }
      return btoa(binary);
    }

    function setStale(stale = true) {
      resultOutput.classList.toggle("stale", stale);
    }

    async function computeHash(message) {
      const encoder = new TextEncoder();
      const data = encoder.encode(message);
      const hashBuffer = await crypto.subtle.digest("SHA-256", data);
      return arrayBufferToHex(hashBuffer);
    }

    async function importKey(base64Key) {
      const keyBuffer = base64ToArrayBuffer(base64Key);
      if (!keyBuffer) return null;
      try {
        return await crypto.subtle.importKey(
          "raw",
          keyBuffer,
          { name: "AES-GCM" },
          false,
          ["encrypt", "decrypt"]
        );
      } catch {
        return null;
      }
    }

    async function encrypt(message, key) {
      const encoder = new TextEncoder();
      const data = encoder.encode(message);
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const encrypted = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, data);
      const combined = new Uint8Array(iv.length + encrypted.byteLength);
      combined.set(iv);
      combined.set(new Uint8Array(encrypted), iv.length);
      return arrayBufferToBase64(combined.buffer);
    }

    async function decrypt(base64Cipher, key) {
      const combined = base64ToArrayBuffer(base64Cipher);
      if (!combined || combined.byteLength < 13) return null;
      const iv = new Uint8Array(combined.slice(0, 12));
      const data = combined.slice(12);
      try {
        const decrypted = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, data);
        return new TextDecoder().decode(decrypted);
      } catch {
        return null;
      }
    }

    async function updateAll() {
      const msg = messageInput.value.trim();
      const func = functionSelect.value;
      const keyBase64 = keyInput.value.trim();

      // Hash immer berechnen
      if (msg) {
        try {
          const hash = await computeHash(msg);
          hashOutput.textContent = hash;
        } catch {
          hashOutput.textContent = "Fehler beim Hashen";
        }
      } else {
        hashOutput.textContent = "";
      }

      // Verschl√ºsselung/Entschl√ºsselung
      if (!msg || !keyBase64) {
        setStale(true);
        return;
      }

      const key = await importKey(keyBase64);
      if (!key) {
        resultOutput.textContent = "Ung√ºltiger Schl√ºssel";
        setStale(true);
        return;
      }

      let result = "";
      if (func === "encrypt") {
        result = await encrypt(msg, key);
      } else if (func === "decrypt") {
        const plain = await decrypt(msg, key);
        result = plain ?? "Fehler bei Entschl√ºsselung";
      }

      resultOutput.textContent = result;
      setStale(false);
    }

    messageInput.addEventListener("input", () => {
      setStale(true);
      updateAll();
    });
    keyInput.addEventListener("input", () => {
      setStale(true);
      updateAll();
    });
    functionSelect.addEventListener("change", () => {
      setStale(true);
      updateAll();
    });

    copyHashBtn.onclick = () => navigator.clipboard.writeText(hashOutput.textContent);
    copyKeyBtn.onclick = () => navigator.clipboard.writeText(keyInput.value.trim());
    copyResultBtn.onclick = () => navigator.clipboard.writeText(resultOutput.textContent);

    // Initial
    updateAll();
  </script>
</body>
</html>
