<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Symmetrische Verschlüsselung Demo</title>
  <link rel="stylesheet" href="style.css" />
  <style>
    /* Kleine Anpassungen für Demo-Zwecke */
    label {
      display: block;
      margin-top: 1rem;
      font-weight: 600;
    }
    textarea, input, select {
      width: 100%;
      box-sizing: border-box;
      padding: 0.5rem;
      margin-top: 0.3rem;
      font-family: monospace;
      font-size: 1rem;
      border: 1px solid #ccc;
      border-radius: 4px;
      transition: border-color 0.3s ease;
    }
    textarea:focus, input:focus, select:focus {
      border-color: #004080;
      outline: none;
    }
    .output {
      background-color: #f5f5f5;
      padding: 0.5rem;
      min-height: 3rem;
      white-space: pre-wrap;
      word-wrap: break-word;
      border: 1px solid #ccc;
      border-radius: 4px;
      margin-top: 0.3rem;
      position: relative;
    }
    .output.not-updated {
      background-color: #fff0f0;
      border-color: #cc0000;
      color: #990000;
    }
    button.copy-btn {
      position: absolute;
      right: 0.3rem;
      top: 0.3rem;
      background: #004080;
      color: white;
      border: none;
      padding: 0.2rem 0.6rem;
      border-radius: 3px;
      cursor: pointer;
      font-size: 0.8rem;
      user-select: none;
      transition: background-color 0.3s ease;
    }
    button.copy-btn:hover {
      background: #002850;
    }
  </style>
</head>
<body>
  <header>
    <h1>Symmetrische Verschlüsselung Demo</h1>
    <p class="meta">Generiert von ChatGPT (GPT-4o) – 2025-09-22 – Version 1.0</p>
  </header>

  <!--
    Generiert von ChatGPT (GPT-4o) – 2025-09-22 – Version 1.0

    Anweisung / Prompt:

    Erstelle ein interaktives Web-Tool zur Demonstration symmetrischer Kryptografie
    mit WebCrypto API, das folgende Funktionen bietet:

    1. Ein Textfeld für die Eingabe einer Nachricht (Klartext).

    2. Eine Ausgabefläche für den Hash (SHA-256) der Nachricht, dargestellt als
       Hexadezimal-String.

    3. Ein Auswahlfeld (Select), mit dem die Funktion eingestellt wird:
       - Hash berechnen
       - Nachricht verschlüsseln (AES-GCM)
       - Nachricht entschlüsseln (AES-GCM)

    4. Ein Eingabefeld für den symmetrischen Schlüssel (Base64-kodiert).

    5. Eine Ausgabefläche, die je nach gewählter Funktion die verschlüsselte oder
       entschlüsselte Nachricht (Base64-kodiert) oder den Hash (hexadezimal) anzeigt.

    6. Alle Ausgaben sollen live aktualisiert werden, sobald die Eingaben (Nachricht,
       Schlüssel oder Funktion) geändert werden.

    7. Die Ausgabefelder sollen farblich gekennzeichnet sein, wenn der Inhalt nicht
       aktuell ist (z.B. nach Änderungen im Eingabefeld).

    8. Kopier-Buttons für den Hash, Schlüssel und die Ausgaben (Verschlüsselter oder
       Entschlüsselter Text), die den jeweiligen Text in die Zwischenablage kopieren.

    9. Ein sichtbarer Hinweis, dass es sich um automatisch generierten Demo-Code handelt,
       der nicht für sicherheitskritische Anwendungen geeignet ist.

    Das Ziel ist ein einfach verständliches, nutzerfreundliches Web-Tool zur
    Demonstration von Hashing, Verschlüsselung und Entschlüsselung mit WebCrypto,
    das sowohl Entwickler:innen als auch interessierten Anwender:innen als Lernhilfe dient.
  -->

  <main>
    <section class="warning">
      <strong>⚠️ Hinweis:</strong> Dieses Demo-Tool ist automatisch generiert und dient nur zu Lern- und Demonstrationszwecken. Nicht für produktive oder sicherheitskritische Anwendungen verwenden.
    </section>

    <form id="cryptoForm" autocomplete="off" spellcheck="false">
      <label for="messageInput">Nachricht (Klartext):</label>
      <textarea id="messageInput" rows="4" placeholder="Hier Nachricht eingeben..."></textarea>

      <label for="functionSelect">Funktion wählen:</label>
      <select id="functionSelect" aria-label="Funktion wählen">
        <option value="hash">Hash (SHA-256) berechnen</option>
        <option value="encrypt">Nachricht verschlüsseln (AES-GCM)</option>
        <option value="decrypt">Nachricht entschlüsseln (AES-GCM)</option>
      </select>

      <label for="keyInput">Symmetrischer Schlüssel (Base64):</label>
      <input type="text" id="keyInput" placeholder="Schlüssel in Base64" aria-describedby="keyHelp" />

      <div id="keyHelp" style="font-size: 0.9rem; color: #666; margin-top: 0.2rem;">
        Schlüssel sollte 256-bit (32 Byte) Base64-kodiert sein, z.B. <code>MTIzNDU2Nzg5MGFiY2RlZg==</code>
      </div>

      <label for="outputField">Ausgabe:</label>
      <div class="output not-updated" id="outputField" tabindex="0" aria-live="polite" aria-atomic="true"></div>
      <button type="button" class="copy-btn" id="copyOutputBtn" aria-label="Ausgabe kopieren">Kopieren</button>

      <label for="hashOutput">Hash (SHA-256) (Hexadezimal):</label>
      <div class="output not-updated" id="hashOutput" tabindex="0" aria-live="polite" aria-atomic="true"></div>
      <button type="button" class="copy-btn" id="copyHashBtn" aria-label="Hash kopieren">Kopieren</button>

      <label for="keyOutput">Eingabeschlüssel (Base64):</label>
      <div class="output not-updated" id="keyOutput" tabindex="0" aria-live="polite" aria-atomic="true"></div>
      <button type="button" class="copy-btn" id="copyKeyBtn" aria-label="Schlüssel kopieren">Kopieren</button>
    </form>
  </main>

  <footer>
    <p>Generated by ChatGPT (GPT-4o) – © 2025 – Version 1.0</p>
  </footer>

  <script>
    // Helfer: ArrayBuffer to Hex
    function bufferToHex(buffer) {
      const hexCodes = [];
      const view = new DataView(buffer);
      for (let i = 0; i < view.byteLength; i++) {
        const byte = view.getUint8(i);
        hexCodes.push(byte.toString(16).padStart(2, '0'));
      }
      return hexCodes.join('');
    }

    // Helfer: ArrayBuffer to Base64
    function bufferToBase64(buffer) {
      const bytes = new Uint8Array(buffer);
      let binary = '';
      for (let b of bytes) {
        binary += String.fromCharCode(b);
      }
      return btoa(binary);
    }

    // Helfer: Base64 to ArrayBuffer
    function base64ToBuffer(base64) {
      try {
        const binary = atob(base64);
        const bytes = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) {
          bytes[i] = binary.charCodeAt(i);
        }
        return bytes.buffer;
      } catch {
        return null;
      }
    }

    // Ausgabe-Elemente
    const messageInput = document.getElementById('messageInput');
    const functionSelect = document.getElementById('functionSelect');
    const keyInput = document.getElementById('keyInput');

    const outputField = document.getElementById('outputField');
    const hashOutput = document.getElementById('hashOutput');
    const keyOutput = document.getElementById('keyOutput');

    const copyOutputBtn = document.getElementById('copyOutputBtn');
    const copyHashBtn = document.getElementById('copyHashBtn');
    const copyKeyBtn = document.getElementById('copyKeyBtn');

    // State um festzuhalten, ob Output aktuell ist
    let outputUpdated = false;
    let hashUpdated = false;
    let keyUpdated = false;

    // Status zurücksetzen
    function markNotUpdated(elem) {
      elem.classList.add('not-updated');
    }
    function markUpdated(elem) {
      elem.classList.remove('not-updated');
    }

    // Initial alle als nicht aktualisiert markieren
    markNotUpdated(outputField);
    markNotUpdated(hashOutput);
    markNotUpdated(keyOutput);

    // Funktion: Hash berechnen (SHA-256)
    async function computeHash(msg) {
      const encoder = new TextEncoder();
      const data = encoder.encode(msg);
      const digest = await crypto.subtle.digest('SHA-256', data);
      return bufferToHex(digest);
    }

    // Funktion: Schlüssel importieren für AES-GCM (256 Bit)
    async function importKey(base64Key) {
      const keyBuffer = base64ToBuffer(base64Key);
      if (!keyBuffer || keyBuffer.byteLength !== 32) {
        throw new Error('Schlüssel ist ungültig. Er muss 256-bit (32 Byte) lang und Base64-kodiert sein.');
      }
      return await crypto.subtle.importKey(
        'raw',
        keyBuffer,
        { name: 'AES-GCM' },
        false,
        ['encrypt', 'decrypt']
      );
    }

    // Funktion: Verschlüsseln AES-GCM
    async function encryptMessage(key, msg) {
      const encoder = new TextEncoder();
      const iv = crypto.getRandomValues(new Uint8Array(12)); // 96-bit IV
      const encoded = encoder.encode(msg);
      const ciphertext = await crypto.subtle.encrypt(
        { name: 'AES-GCM', iv },
        key,
        encoded
      );
      // IV + Ciphertext zusammenpacken (IV braucht man zum Entschlüsseln)
      const combined = new Uint8Array(iv.byteLength + ciphertext.byteLength);
      combined.set(iv, 0);
      combined.set(new Uint8Array(ciphertext), iv.byteLength);
      return bufferToBase64(combined.buffer);
    }

    // Funktion: Entschlüsseln AES-GCM
    async function decryptMessage(key, base64Cipher) {
      const combined = base64ToBuffer(base64Cipher);
      if (!combined || combined.byteLength < 13) {
        throw new Error('Ciphertext ungültig oder zu kurz.');
      }
      const iv = combined.slice(0, 12);
      const ciphertext = combined.slice(12);
      const decrypted = await crypto.subtle.decrypt(
        { name: 'AES-GCM', iv: new Uint8Array(iv) },
        key,
        ciphertext
      );
      const decoder = new TextDecoder();
      return decoder.decode(decrypted);
    }

    // Aktualisiere alle Outputs je nach Funktion und Eingaben
    async function updateOutputs() {
      const msg = messageInput.value;
      const func = functionSelect.value;
      const keyBase64 = keyInput.value.trim();

      // Immer Hash aktualisieren
      if (msg.length > 0) {
        try {
          const hash = await computeHash(msg);
          hashOutput.textContent = hash;
          markUpdated(hashOutput);
          hashUpdated = true;
        } catch {
          hashOutput.textContent = 'Fehler beim Hashen';
          markNotUpdated(hashOutput);
          hashUpdated = false;
        }
      } else {
        hashOutput.textContent = '';
        markNotUpdated(hashOutput);
        hashUpdated = false;
      }

      // Schlüssel ausgeben und validieren
      if (keyBase64.length > 0) {
        keyOutput.textContent = keyBase64;
        markUpdated(keyOutput);
        keyUpdated = true;
      } else {
        keyOutput.textContent = '';
        markNotUpdated(keyOutput);
        keyUpdated = false;
      }

      // Funktion Output berechnen
      if (func === 'hash') {
        outputField.textContent = hashOutput.textContent;
        if (hashUpdated) markUpdated(outputField);
        else markNotUpdated(outputField);
        outputUpdated = hashUpdated;
        return;
      }

      // Für Verschlüsselung oder Entschlüsselung ist Schlüssel Pflicht
      if (!keyUpdated) {
        outputField.textContent = 'Bitte gültigen Schlüssel eingeben.';
        markNotUpdated(outputField);
        outputUpdated = false;
        return;
      }

      try {
        const cryptoKey = await importKey(keyBase64);

        if (func === 'encrypt') {
          if (msg.length === 0) {
            outputField.textContent = 'Bitte Nachricht eingeben.';
            markNotUpdated(outputField);
            outputUpdated = false;
            return;
          }
          const encrypted = await encryptMessage(cryptoKey, msg);
          outputField.textContent = encrypted;
          markUpdated(outputField);
          outputUpdated = true;
        } else if (func === 'decrypt') {
          if (msg.length === 0) {
            outputField.textContent = 'Bitte verschlüsselten Text eingeben.';
            markNotUpdated(outputField);
            outputUpdated = false;
            return;
          }
          const decrypted = await decryptMessage(cryptoKey, msg);
          outputField.textContent = decrypted;
          markUpdated(outputField);
          outputUpdated = true;
        }
      } catch (e) {
        outputField.textContent = 'Fehler: ' + e.message;
        markNotUpdated(outputField);
        outputUpdated = false;
      }
    }

    // Kopierfunktion
    function setupCopyButton(button, element) {
      button.addEventListener('click', () => {
        if (element.textContent.length === 0) return;
        navigator.clipboard.writeText(element.textContent).then(() => {
          button.textContent = '✔️ Kopiert';
          setTimeout(() => {
            button.textContent = 'Kopieren';
          }, 1500);
        });
      });
    }

    // Event-Listener
    [messageInput, functionSelect, keyInput].forEach(el => {
      el.addEventListener('input', () => {
        // Nach Änderung alle Outputs als nicht aktuell markieren
        markNotUpdated(outputField);
        markNotUpdated(hashOutput);
        markNotUpdated(keyOutput);
        outputUpdated = false;
        hashUpdated = false;
        keyUpdated = false;

        // Update mit Timeout um UI flüssig zu halten (Throttle)
        if (window.updateTimeout) clearTimeout(window.updateTimeout);
        window.updateTimeout = setTimeout(() => updateOutputs(), 300);
      });
    });

    setupCopyButton(copyOutputBtn, outputField);
    setupCopyButton(copyHashBtn, hashOutput);
    setupCopyButton(copyKeyBtn, keyOutput);

    // Initialer Aufruf
    updateOutputs();
  </script>
</body>
</html>
