<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Vorschlag: Unterst√ºtzung von Hash-Angaben im URL-Fragment und Erweiterung des integrity-Attributs um hexadezimale Hashwerte</title>
  <style>
    body {
      font-family: sans-serif;
      line-height: 1.6;
      max-width: 800px;
      margin: 2em auto;
      padding: 0 1em;
      color: #000;
      background: #fff;
    }

    h1, h2, h3 {
      margin-top: 2em;
      margin-bottom: 0.5em;
    }

    nav {
      margin-bottom: 2em;
    }

    nav ul {
      list-style: none;
      padding-left: 0;
    }

    nav ul li {
      margin: 0.25em 0;
    }

    nav a {
      text-decoration: none;
      color: black;
    }

    nav a:hover {
      text-decoration: underline;
    }

    code {
      background: #eee;
      padding: 0.1em 0.3em;
      border-radius: 3px;
      font-family: monospace;
    }

    pre {
      background: #f5f5f5;
      padding: 1em;
      overflow-x: auto;
      border: 1px solid #ccc;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 1em;
    }

    th, td {
      border: 1px solid #000;
      padding: 0.5em;
      text-align: left;
      vertical-align: top;
    }

    .small {
      font-size: 0.9em;
      color: #333;
    }
  </style>
</head>
<body>

<h1>Vorschlag: Unterst√ºtzung von Hash-Angaben im URL-Fragment und Erweiterung des integrity-Attributs um hexadezimale Hashwerte</h1>

<section id="einleitung">
  <h2>1. Einleitung</h2>

  <p>
    Dieser Vorschlag beschreibt eine standardisierte Syntax zur Angabe von Hashes in URLs, sowohl im URL-Fragment (<code>#</code>) als auch im Query-String (<code>?</code>), um eine einfache und flexible Dateiintegrit√§tspr√ºfung zu erm√∂glichen.
  </p>

  <p>
    Die Syntax orientiert sich am bestehenden <code>integrity</code>-Attribut (Subresource Integrity, SRI) und erweitert dieses um:
  </p>

  <ul>
    <li>Unterst√ºtzung von hexadezimal kodierten Hashwerten neben der bisher definierten Base64-Kodierung.</li>
    <li>Klare Syntax zur Angabe des Algorithmus und der Kodierung, z.‚ÄØB. <code>integrity="sha256:abcdef1234567890..."</code>.</li>
    <li>Der Algorithmus (sha256) wird explizit angegeben, um Verwechslungen zu vermeiden.</li>
    <li>Die Kodierung in hexadezimal erschliesst sich eindeutig aus der Syntax und das verwendete Trennzeichen ":"</li>
    <li>Optional k√∂nnen weitere Metadaten oder Attribute erg√§nzt werden (z.‚ÄØB. Erstellungsdatum).</li>
  </ul>

  <p>
    Diese Struktur erm√∂glicht eine dynamische Auswertung des Algorithmus und der Kodierung, schafft Kompatibilit√§t zu bestehenden Webstandards und erleichtert die Integration in verschiedene Umgebungen.
  </p>

  <p>
    Ziel ist es, eine robuste, nachvollziehbare und standardisierte L√∂sung zur Dateiintegrit√§tspr√ºfung auf Client- und Serverseite zu schaffen.
  </p>

  <h3>Motivation</h3>
  <p>
    Dateiintegrit√§t ist im Web eine essenzielle Voraussetzung f√ºr Sicherheit, Nachvollziehbarkeit und Datenqualit√§t. Das bestehende <code>integrity</code>-Attribut definiert zwar eine Basis, unterst√ºtzt aber nur Base64-kodierte Hashes und ist auf bestimmte Algorithmen beschr√§nkt.
  </p>
  <p>
    Die Erweiterung um hexadezimale Hashwerte, flexible Algorithmen und die Einbettung in URL-Fragmente oder Query-Parameter bietet mehr Transparenz und Anpassungsf√§higkeit. Au√üerdem k√∂nnen so Integrit√§tspr√ºfungen auch ohne Serverbeteiligung clientseitig einfach realisiert werden.
  </p>

  <p>
    Dieses Proposal schl√§gt daher eine leichtgewichtige, aber leistungsf√§hige Syntax vor, die die Vorteile bestehender Konzepte verbindet und gleichzeitig neue Anwendungsszenarien erm√∂glicht.
  </p>

  <p>
    Im Folgenden werden Grundlagen, Beispiele und die komplement√§re Nutzung von Fragment und Query-Parametern erl√§utert.
  </p>
</section>

<nav>
  <h2>Inhaltsverzeichnis</h2>
  <ul>
    <li><a href="#einleitung">1. Einleitung</a></li>
    <li><a href="#grundlagen">2. Grundlagen: Fragment vs. Query</a></li>
    <li><a href="#beispiel">3. Beispiel: Clear.gif</a></li>
    <li><a href="#strategie">4. Komplement√§re Umsetzung</a></li>
    <li><a href="#analyse">5. Vor- und Nachteile</a></li>
    <li><a href="#fazit">6. Fazit & Empfehlung</a></li>
  </ul>
</nav>

<section id="grundlagen">
  <h2>2. Grundlagen: Fragment vs. Query</h2>

  <h3>2.1 URL-Fragment (<code>#...</code>)</h3>
  <p>
    Der Fragment-Teil einer URL wird nicht an den Server √ºbertragen. Er eignet sich f√ºr clientseitige Pr√ºfungen im Browser.
  </p>

  <h3>2.2 Query-String (<code>?key=value</code>)</h3>
  <p>
    Query-Parameter werden an den Server gesendet. Dadurch k√∂nnen Hashes dort verarbeitet, gespeichert oder √ºberpr√ºft werden.
  </p>
</section>


<section id="beispiel">
  <h2>3. Beispiel: Clear.gif</h2>
  <p>Eine transparente 1√ó1-Pixel-Grafik:</p>
  <ul>
    <li>Datei: <code>Clear.gif</code></li>
    <li>Dateigr√∂√üe: ca. 43 Byte</li>
    <li>SHA-256: <code>b4c52d276e8e2f0c7a97e3fbd70b18d30b11aa5ac26a795e4c225b2cf1e8c7bc4</code></li>
  </ul>

  <h3>3.1 Fragment-Hash</h3>
  <p>
    Beispiel-URL:
    <code>clear.gif#sha256=b4c52d276e8e2f0c7a97e3fbd70b18d30b11aa5ac26a795e4c225b2cf1e8c7bc4</code>
  </p>

  <h3>3.2 Query-Parameter</h3>
  <p>
    Beispiel-URL:
    <code>clear.gif?sha256=b4c52d276e8e2f0c7a97e3fbd70b18d30b11aa5ac26a795e4c225b2cf1e8c7bc4</code>
  </p>

  <h3>3.3 Validierungs-Beispiel mit unserem Validator</h3>
  <p>
    Hier ein funktionierender Link zum Online-Validator, der die Datei l√§dt und clientseitig validiert:
  </p>
  <p>
    <a href="example-validator.html?url=https://kuukbln.github.io/Proposal/Clear.gif#sha256:b4c52d276e8e2f0c7a97e3fbd70b18d30b11aa5ac26a795e4c225b2cf1e8c7bc4" target="_blank" rel="noopener noreferrer">
      üîó Clear.gif mit SHA-256 Hash pr√ºfen (Online Validator: falscher Hash)
    </a>
  </p>
  <p>
    <a href="example-validator.html?url=https://kuukbln.github.io/Proposal/Clear.gif#sha256:cf4724b2f736ed1a0ae6bc28f1ead963d9cd2c1fd87b6ef32e7799fc1c5c8bda" target="_blank" rel="noopener noreferrer">
      üîó Clear.gif mit SHA-256 Hash pr√ºfen (Online Validator)
    </a>
  </p>
  
  <small>
    ‚ö†Ô∏è Hinweis: Die Validierung erfolgt vollst√§ndig im Browser (clientseitig) ‚Äì somit ist keine Serververarbeitung n√∂tig. 
    Diese Methode eignet sich gut f√ºr Integrit√§tspr√ºfungen in unabh√§ngigen Clients oder statischen Webanwendungen.
  </small>
</section>

<section id="strategie">
  <h2>4. Komplement√§re Umsetzung von Fragment und Query</h2>
  <p>
    Fragment und Query-Parameter bieten unterschiedliche Vorteile bei der Einbettung eines Hashwerts in eine URL. 
    Ihre kombinierte Nutzung stellt keine Notl√∂sung dar, sondern eine bewusst entworfene, komplement√§re Umsetzung:
  </p>
  <ul>
    <li><strong>Fragment</strong>: erm√∂glicht eine clientseitige Integrit√§tspr√ºfung im Browser, unabh√§ngig vom Server</li>
    <li><strong>Query-Parameter</strong>: erlaubt serverseitige Auswertung, Logging und API-basierte Pr√ºfungen</li>
  </ul>
  <p>
    Durch diese parallele Integration kann der Hash sowohl auf Client- als auch auf Serverebene gepr√ºft oder weiterverarbeitet werden ‚Äì 
    ohne sich gegenseitig auszuschlie√üen.
  </p>
</section>

<section id="analyse">
  <h2>5. Vor- und Nachteile</h2>
  <table>
    <thead>
      <tr>
        <th>Variante</th>
        <th>Vorteile</th>
        <th>Nachteile</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Fragment</td>
        <td>
          <ul>
            <li>Keine Serverlast</li>
            <li>Clientseitig pr√ºfbar</li>
            <li>Bleibt vollst√§ndig im Browser</li>
          </ul>
        </td>
        <td>
          <ul>
            <li>Wird nicht an den Server gesendet</li>
            <li>Kann durch Weiterleitungen verloren gehen</li>
            <li>Fehlt in Logs</li>
          </ul>
        </td>
      </tr>
      <tr>
        <td>Query-String</td>
        <td>
          <ul>
            <li>Serverseitig verf√ºgbar</li>
            <li>F√ºr Logging &amp; APIs geeignet</li>
            <li>Kann serverseitig validiert werden</li>
          </ul>
        </td>
        <td>
          <ul>
            <li>Erh√∂ht URL-L√§nge</li>
            <li>Kollidiert evtl. mit Caching-Mechanismen</li>
          </ul>
        </td>
      </tr>
    </tbody>
  </table>
</section>

<section id="fazit">
  <h2>6. Fazit &amp; Empfehlung</h2>
  <p>
    Die Nutzung von Hashwerten im URL-Fragment ist eine einfache und effektive L√∂sung zur clientseitigen Validierung. 
    Um eine vollst√§ndige Pr√ºfbarkeit in verschiedenen Anwendungsszenarien zu erm√∂glichen, empfiehlt sich zus√§tzlich die Einbettung im Query-String.
  </p>
  <p>
    Diese komplement√§re Umsetzung erm√∂glicht eine robuste und vielseitige Integrit√§tspr√ºfung von Dateien ‚Äì sowohl im Frontend als auch im Backend.
  </p>
  <p>
    Die Validierung sollte idealerweise clientseitig erfolgen, z.‚ÄØB. durch JavaScript im Browser, kann aber auch serverseitig umgesetzt werden.
  </p>
</section>

<footer>
  <p class="small" style="margin-top: 3em;">&copy; 2025 ‚Äì Technischer Vorschlag zur Integrit√§tspr√ºfung √ºber URLs</p>
</footer>

</body>
</html>
